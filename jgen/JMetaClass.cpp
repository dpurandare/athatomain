/*
 * File: JMetaClass.cpp
 * Created Date: Monday August 25th 2014
 * Author: Deepak Purandare
 * -----
 * Last Modified: Monday August 25th 2014 12:18:51 pm
 * Modified By: Deepak Purandare - <deepak_purandare@hotmail.com>
 * -----
 * Copyright (c) 2019 Purndare Consulting
 * This software is made available under GNU General Public License Version 3
 * Visit http://www.gnu.org/licenses/gpl-3.0.html for terms of usage.
 * Created on February 23, 2014, 8:59 PM
 */

#include "JMetaClass.h"
#include "../cobmain.h"
#include <stdio.h>
#include <iostream>
#include <fstream>
#include "../global.h"
#include <boost/algorithm/string.hpp>

JMetaClass::JMetaClass() {
}

JMetaClass::JMetaClass(string pname, JGenerator * pparent){
    name = pname;
    parent = pparent;
    fields = new list <JMetaField *>;
    methods = new list <JMetaMethod *>;
    staticdecl = new list <string>;
    constructor = new list <string>;    
    entryfunction = new list <string>;    
}
string JMetaClass::getname(){
    return name;
}
void JMetaClass::addextInclude(string pextinc){
    // check the duplicates while dumping. 
    bool duplicate = false;
    list <string>::iterator i;
    for(i = extIncludes.begin(); i != extIncludes.end(); ++i){
        if(boost::iequals(pextinc, (*i))) {
            duplicate = true;
            break;
        }
    }
    if(duplicate == false) extIncludes.push_back(pextinc);
}
void JMetaClass::setExtends(string pextend){
    extends = pextend;
}
void JMetaClass::addField(JMetaField * pfield){
    fields->push_back(pfield);
}
void JMetaClass::addMethod(JMetaMethod * pmethod){
    methods->push_back(pmethod);
}

void JMetaClass::addStaticDeclaration(string pstr){
    staticdecl->push_back(pstr);
}

void JMetaClass::addConstructorItem(string pstr){
    constructor->push_back(pstr);
}
JMetaMethod * JMetaClass::getMethod(string pmethodname){
    JMetaMethod * ret = NULL;
    list <JMetaMethod *>::iterator i;
    for(i = methods->begin(); i != methods->end(); ++i){
        if(boost::iequals(pmethodname, (*i)->getMethodName())){
            ret = (*i);
            break;
        }
    } 
    return ret;
}
int JMetaClass::serialize(string pFileName){
    int successflag = false;

    int level = 0;
    string tabstr = "";    
    for(int ix = 0; ix < level+1; ix++) tabstr.append("    ");
    
    
    stringstream s;    
// Print the header
    s << "/*************************************************************************\n";
    s << " * File Name : " << pFileName << "\n";
    s << " * This file is auto-generated by " << "cob" << APP_VERSION << ":" << APP_BUILD << "\n";
    s << " * Use of this file limited to demonstration and evaluation.\n";
    s << " * All rights reserved : deepak_purandare@hotmail.com \n";
    s << " *************************************************************************/\n";
    
// Package name ... implement...
//    s << "package fileio;\n"; // implement ... this needs a thought.
//    s << "\n";
    
// external includes...
    list <string>::iterator k;
    for(k = extIncludes.begin(); k != extIncludes.end(); ++k) {
        s << "import " << (*k) << ";\n";
    }
    // Class definition begins
    s << "\nclass " << getJname(name.c_str()) << " extends " ;
    if(extends.empty()) {
        s << "Object" << "{\n";
    } else {        
        s << extends << " {\n";
    }
    // dump the fields.
    list <JMetaField *>::iterator i;
    for(i = fields->begin(); i != fields->end(); ++i){
        JMetaField * jmf = (*i);
        jmf->serialize(&s, level+1);
    }
    // dump the static declarations
    if(! staticdecl->empty()){
        s << "\n";
        s << tabstr << "// Static declarations. check out for 88 fields.\n";
        s << tabstr << "static {\n";        
        list <string>::iterator i;
        for(i = staticdecl->begin(); i != staticdecl->end(); ++i){
            s << tabstr << "    " << (*i) << "\n";
        }        
        s << tabstr << "}\n";        
    }
    // dump the constructor
    s << "\n";
    if(! constructor->empty()) {
        s << tabstr << getJname(name.c_str()) << "(){\n";
        list <string>::iterator i;
        for(i = constructor->begin(); i != constructor->end(); ++i){
            s << tabstr << "    " << (*i) << "\n";
        }        
        s << tabstr << "}\n\n";
    }    
    // dump the methods
    list <JMetaMethod *>::iterator j;
    for(j = methods->begin(); j != methods->end(); ++j){
        JMetaMethod * jmm = (*j);
        jmm->serialize(&s, level+1);
    }
        
    s << "}\n";
    
    if(!pFileName.empty() && dofiledump){
        stringstream of;
        of << getTargetPath() << "/" << pFileName << ".java";
        /*
        fstream clsfile;
        //ofstream clsfile;
        
        clsfile.open(getJname(of.str().c_str()), std::fstream::out ); //std::ofstream::out | std::ofstream::trunc);
        if(clsfile.fail()){
            cout << "File open failure error no: " << strerror(errno) << '\n';
        }
        if( ! clsfile.is_open()){
            cout << "Error opening " << of.str() << "\n";
        }
        clsfile << s.str();
        clsfile.close();
         */
        FILE * clsfile = fopen(of.str().c_str(), "w+");
        if(clsfile != NULL){
            fprintf(clsfile, "%s", s.str().c_str());
            //fputs(s.str(), clsfile);
            fclose(clsfile);
        }
    } else {
        cout << s.str();
    }
    // for time being. comment it later. 
    //cout << s.str();
    return successflag;
}

JMetaClass::~JMetaClass() {
    list <JMetaField *>::iterator i;
    for(i = fields->begin(); i != fields->end(); ++i){
        delete (*i);
    }
    delete fields;
    list <JMetaMethod *>::iterator j;
    for(j = methods->begin(); j != methods->end(); ++j){
        delete (*j);
    }
    delete methods;
    delete constructor;
    delete entryfunction;
}

